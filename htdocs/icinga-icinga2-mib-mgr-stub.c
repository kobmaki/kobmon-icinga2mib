/*
 * This C file has been generated by smidump 0.4.8.
 * It is intended to be used with the NET-SNMP library.
 *
 * This C file is derived from the ICINGA-ICINGA2-MIB module.
 *
 * $Id$
 */

#include <stdlib.h>

#include <ucd-snmp/asn1.h>
#include <ucd-snmp/snmp.h>
#include <ucd-snmp/snmp_api.h>
#include <ucd-snmp/snmp_client.h>

#include "icinga-icinga2-mib.h"

static oid i2ObjectType[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 1};
static oid i2Name[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 3};
static oid i2StateType[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 4};
static oid i2DisplayName[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 5};
static oid i2Notes[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 6};
static oid i2NotesUrl[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 7};
static oid i2Output[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 8};
static oid i2CheckCommand[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 9};
static oid i2CheckAttempt[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 10};
static oid i2EnableActiveChecks[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 11};
static oid i2EnableEventHandler[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 12};
static oid i2EnableFlapping[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 13};
static oid i2EnableNotfications[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 14};
static oid i2EnablePassiveCheck[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 15};
static oid i2EnablePerfdata[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 16};
static oid i2Active[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 17};
static oid i2Global[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 18};
static oid i2Address[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 19};
static oid i2Address6[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 20};
static oid i2Parent[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 21};
static oid i2HaMode[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 22};
static oid i2LastCheck[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 99};
static oid i2CheckInterval[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 100};
static oid i2CheckPeriod[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 0, 101};
static oid i2HostName[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 1, 1};
static oid i2StateHost[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 1, 4};
static oid i2ServiceName[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 2, 1};
static oid i2StateService[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 2, 2};
static oid i2NotificationType[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 6};
static oid i2UserPager[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 10, 1};
static oid i2EndpointName[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 13, 1};
static oid i2ZoneName[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 1, 14, 1};
static oid i2DaemonStatus[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 8, 1};
static oid i2ClusterStatus[] = {1, 3, 6, 1, 4, 1, 12483, 999, 2, 2, 8, 2};

int icinga_icinga2_mib_mgr_get_i2ObjectAttributes(struct snmp_session *s, i2ObjectAttributes_t **i2ObjectAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2NotificationType, sizeof(i2NotificationType)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2ObjectAttributes = (i2ObjectAttributes_t *) malloc(sizeof(i2ObjectAttributes_t));
    if (! *i2ObjectAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2NotificationType)/sizeof(oid)
            && memcmp(vars->name, i2NotificationType, sizeof(i2NotificationType)) == 0) {
            (*i2ObjectAttributes)->__i2NotificationType = *vars->val.integer;
            (*i2ObjectAttributes)->i2NotificationType = &((*i2ObjectAttributes)->__i2NotificationType);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2GenericAttribute(struct snmp_session *s, i2GenericAttribute_t **i2GenericAttribute)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2ObjectType, sizeof(i2ObjectType)/sizeof(oid));
    snmp_add_null_var(request, i2Name, sizeof(i2Name)/sizeof(oid));
    snmp_add_null_var(request, i2StateType, sizeof(i2StateType)/sizeof(oid));
    snmp_add_null_var(request, i2DisplayName, sizeof(i2DisplayName)/sizeof(oid));
    snmp_add_null_var(request, i2Notes, sizeof(i2Notes)/sizeof(oid));
    snmp_add_null_var(request, i2NotesUrl, sizeof(i2NotesUrl)/sizeof(oid));
    snmp_add_null_var(request, i2Output, sizeof(i2Output)/sizeof(oid));
    snmp_add_null_var(request, i2CheckCommand, sizeof(i2CheckCommand)/sizeof(oid));
    snmp_add_null_var(request, i2CheckAttempt, sizeof(i2CheckAttempt)/sizeof(oid));
    snmp_add_null_var(request, i2EnableActiveChecks, sizeof(i2EnableActiveChecks)/sizeof(oid));
    snmp_add_null_var(request, i2EnableEventHandler, sizeof(i2EnableEventHandler)/sizeof(oid));
    snmp_add_null_var(request, i2EnableFlapping, sizeof(i2EnableFlapping)/sizeof(oid));
    snmp_add_null_var(request, i2EnableNotfications, sizeof(i2EnableNotfications)/sizeof(oid));
    snmp_add_null_var(request, i2EnablePassiveCheck, sizeof(i2EnablePassiveCheck)/sizeof(oid));
    snmp_add_null_var(request, i2EnablePerfdata, sizeof(i2EnablePerfdata)/sizeof(oid));
    snmp_add_null_var(request, i2Active, sizeof(i2Active)/sizeof(oid));
    snmp_add_null_var(request, i2Global, sizeof(i2Global)/sizeof(oid));
    snmp_add_null_var(request, i2Address, sizeof(i2Address)/sizeof(oid));
    snmp_add_null_var(request, i2Address6, sizeof(i2Address6)/sizeof(oid));
    snmp_add_null_var(request, i2Parent, sizeof(i2Parent)/sizeof(oid));
    snmp_add_null_var(request, i2HaMode, sizeof(i2HaMode)/sizeof(oid));
    snmp_add_null_var(request, i2LastCheck, sizeof(i2LastCheck)/sizeof(oid));
    snmp_add_null_var(request, i2CheckInterval, sizeof(i2CheckInterval)/sizeof(oid));
    snmp_add_null_var(request, i2CheckPeriod, sizeof(i2CheckPeriod)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2GenericAttribute = (i2GenericAttribute_t *) malloc(sizeof(i2GenericAttribute_t));
    if (! *i2GenericAttribute) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2ObjectType)/sizeof(oid)
            && memcmp(vars->name, i2ObjectType, sizeof(i2ObjectType)) == 0) {
            (*i2GenericAttribute)->__i2ObjectType = *vars->val.integer;
            (*i2GenericAttribute)->i2ObjectType = &((*i2GenericAttribute)->__i2ObjectType);
        }
        if (vars->name_length > sizeof(i2Name)/sizeof(oid)
            && memcmp(vars->name, i2Name, sizeof(i2Name)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Name, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2NameLength = vars->val_len;
            (*i2GenericAttribute)->i2Name = (*i2GenericAttribute)->__i2Name;
        }
        if (vars->name_length > sizeof(i2StateType)/sizeof(oid)
            && memcmp(vars->name, i2StateType, sizeof(i2StateType)) == 0) {
            (*i2GenericAttribute)->__i2StateType = *vars->val.integer;
            (*i2GenericAttribute)->i2StateType = &((*i2GenericAttribute)->__i2StateType);
        }
        if (vars->name_length > sizeof(i2DisplayName)/sizeof(oid)
            && memcmp(vars->name, i2DisplayName, sizeof(i2DisplayName)) == 0) {
            memcpy((*i2GenericAttribute)->__i2DisplayName, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2DisplayNameLength = vars->val_len;
            (*i2GenericAttribute)->i2DisplayName = (*i2GenericAttribute)->__i2DisplayName;
        }
        if (vars->name_length > sizeof(i2Notes)/sizeof(oid)
            && memcmp(vars->name, i2Notes, sizeof(i2Notes)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Notes, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2NotesLength = vars->val_len;
            (*i2GenericAttribute)->i2Notes = (*i2GenericAttribute)->__i2Notes;
        }
        if (vars->name_length > sizeof(i2NotesUrl)/sizeof(oid)
            && memcmp(vars->name, i2NotesUrl, sizeof(i2NotesUrl)) == 0) {
            memcpy((*i2GenericAttribute)->__i2NotesUrl, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2NotesUrlLength = vars->val_len;
            (*i2GenericAttribute)->i2NotesUrl = (*i2GenericAttribute)->__i2NotesUrl;
        }
        if (vars->name_length > sizeof(i2Output)/sizeof(oid)
            && memcmp(vars->name, i2Output, sizeof(i2Output)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Output, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2OutputLength = vars->val_len;
            (*i2GenericAttribute)->i2Output = (*i2GenericAttribute)->__i2Output;
        }
        if (vars->name_length > sizeof(i2CheckCommand)/sizeof(oid)
            && memcmp(vars->name, i2CheckCommand, sizeof(i2CheckCommand)) == 0) {
            memcpy((*i2GenericAttribute)->__i2CheckCommand, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2CheckCommandLength = vars->val_len;
            (*i2GenericAttribute)->i2CheckCommand = (*i2GenericAttribute)->__i2CheckCommand;
        }
        if (vars->name_length > sizeof(i2CheckAttempt)/sizeof(oid)
            && memcmp(vars->name, i2CheckAttempt, sizeof(i2CheckAttempt)) == 0) {
            (*i2GenericAttribute)->__i2CheckAttempt = *vars->val.integer;
            (*i2GenericAttribute)->i2CheckAttempt = &((*i2GenericAttribute)->__i2CheckAttempt);
        }
        if (vars->name_length > sizeof(i2EnableActiveChecks)/sizeof(oid)
            && memcmp(vars->name, i2EnableActiveChecks, sizeof(i2EnableActiveChecks)) == 0) {
            (*i2GenericAttribute)->__i2EnableActiveChecks = *vars->val.integer;
            (*i2GenericAttribute)->i2EnableActiveChecks = &((*i2GenericAttribute)->__i2EnableActiveChecks);
        }
        if (vars->name_length > sizeof(i2EnableEventHandler)/sizeof(oid)
            && memcmp(vars->name, i2EnableEventHandler, sizeof(i2EnableEventHandler)) == 0) {
            (*i2GenericAttribute)->__i2EnableEventHandler = *vars->val.integer;
            (*i2GenericAttribute)->i2EnableEventHandler = &((*i2GenericAttribute)->__i2EnableEventHandler);
        }
        if (vars->name_length > sizeof(i2EnableFlapping)/sizeof(oid)
            && memcmp(vars->name, i2EnableFlapping, sizeof(i2EnableFlapping)) == 0) {
            (*i2GenericAttribute)->__i2EnableFlapping = *vars->val.integer;
            (*i2GenericAttribute)->i2EnableFlapping = &((*i2GenericAttribute)->__i2EnableFlapping);
        }
        if (vars->name_length > sizeof(i2EnableNotfications)/sizeof(oid)
            && memcmp(vars->name, i2EnableNotfications, sizeof(i2EnableNotfications)) == 0) {
            (*i2GenericAttribute)->__i2EnableNotfications = *vars->val.integer;
            (*i2GenericAttribute)->i2EnableNotfications = &((*i2GenericAttribute)->__i2EnableNotfications);
        }
        if (vars->name_length > sizeof(i2EnablePassiveCheck)/sizeof(oid)
            && memcmp(vars->name, i2EnablePassiveCheck, sizeof(i2EnablePassiveCheck)) == 0) {
            (*i2GenericAttribute)->__i2EnablePassiveCheck = *vars->val.integer;
            (*i2GenericAttribute)->i2EnablePassiveCheck = &((*i2GenericAttribute)->__i2EnablePassiveCheck);
        }
        if (vars->name_length > sizeof(i2EnablePerfdata)/sizeof(oid)
            && memcmp(vars->name, i2EnablePerfdata, sizeof(i2EnablePerfdata)) == 0) {
            (*i2GenericAttribute)->__i2EnablePerfdata = *vars->val.integer;
            (*i2GenericAttribute)->i2EnablePerfdata = &((*i2GenericAttribute)->__i2EnablePerfdata);
        }
        if (vars->name_length > sizeof(i2Active)/sizeof(oid)
            && memcmp(vars->name, i2Active, sizeof(i2Active)) == 0) {
            (*i2GenericAttribute)->__i2Active = *vars->val.integer;
            (*i2GenericAttribute)->i2Active = &((*i2GenericAttribute)->__i2Active);
        }
        if (vars->name_length > sizeof(i2Global)/sizeof(oid)
            && memcmp(vars->name, i2Global, sizeof(i2Global)) == 0) {
            (*i2GenericAttribute)->__i2Global = *vars->val.integer;
            (*i2GenericAttribute)->i2Global = &((*i2GenericAttribute)->__i2Global);
        }
        if (vars->name_length > sizeof(i2Address)/sizeof(oid)
            && memcmp(vars->name, i2Address, sizeof(i2Address)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Address, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2AddressLength = vars->val_len;
            (*i2GenericAttribute)->i2Address = (*i2GenericAttribute)->__i2Address;
        }
        if (vars->name_length > sizeof(i2Address6)/sizeof(oid)
            && memcmp(vars->name, i2Address6, sizeof(i2Address6)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Address6, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2Address6Length = vars->val_len;
            (*i2GenericAttribute)->i2Address6 = (*i2GenericAttribute)->__i2Address6;
        }
        if (vars->name_length > sizeof(i2Parent)/sizeof(oid)
            && memcmp(vars->name, i2Parent, sizeof(i2Parent)) == 0) {
            memcpy((*i2GenericAttribute)->__i2Parent, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2ParentLength = vars->val_len;
            (*i2GenericAttribute)->i2Parent = (*i2GenericAttribute)->__i2Parent;
        }
        if (vars->name_length > sizeof(i2HaMode)/sizeof(oid)
            && memcmp(vars->name, i2HaMode, sizeof(i2HaMode)) == 0) {
            (*i2GenericAttribute)->__i2HaMode = *vars->val.integer;
            (*i2GenericAttribute)->i2HaMode = &((*i2GenericAttribute)->__i2HaMode);
        }
        if (vars->name_length > sizeof(i2LastCheck)/sizeof(oid)
            && memcmp(vars->name, i2LastCheck, sizeof(i2LastCheck)) == 0) {
            memcpy((*i2GenericAttribute)->__i2LastCheck, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2LastCheckLength = vars->val_len;
            (*i2GenericAttribute)->i2LastCheck = (*i2GenericAttribute)->__i2LastCheck;
        }
        if (vars->name_length > sizeof(i2CheckInterval)/sizeof(oid)
            && memcmp(vars->name, i2CheckInterval, sizeof(i2CheckInterval)) == 0) {
            (*i2GenericAttribute)->__i2CheckInterval = *vars->val.integer;
            (*i2GenericAttribute)->i2CheckInterval = &((*i2GenericAttribute)->__i2CheckInterval);
        }
        if (vars->name_length > sizeof(i2CheckPeriod)/sizeof(oid)
            && memcmp(vars->name, i2CheckPeriod, sizeof(i2CheckPeriod)) == 0) {
            memcpy((*i2GenericAttribute)->__i2CheckPeriod, vars->val.string, vars->val_len);
            (*i2GenericAttribute)->_i2CheckPeriodLength = vars->val_len;
            (*i2GenericAttribute)->i2CheckPeriod = (*i2GenericAttribute)->__i2CheckPeriod;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2HostAttributes(struct snmp_session *s, i2HostAttributes_t **i2HostAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2HostName, sizeof(i2HostName)/sizeof(oid));
    snmp_add_null_var(request, i2StateHost, sizeof(i2StateHost)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2HostAttributes = (i2HostAttributes_t *) malloc(sizeof(i2HostAttributes_t));
    if (! *i2HostAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2HostName)/sizeof(oid)
            && memcmp(vars->name, i2HostName, sizeof(i2HostName)) == 0) {
            memcpy((*i2HostAttributes)->__i2HostName, vars->val.string, vars->val_len);
            (*i2HostAttributes)->_i2HostNameLength = vars->val_len;
            (*i2HostAttributes)->i2HostName = (*i2HostAttributes)->__i2HostName;
        }
        if (vars->name_length > sizeof(i2StateHost)/sizeof(oid)
            && memcmp(vars->name, i2StateHost, sizeof(i2StateHost)) == 0) {
            (*i2HostAttributes)->__i2StateHost = *vars->val.integer;
            (*i2HostAttributes)->i2StateHost = &((*i2HostAttributes)->__i2StateHost);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2ServiceAttributes(struct snmp_session *s, i2ServiceAttributes_t **i2ServiceAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2ServiceName, sizeof(i2ServiceName)/sizeof(oid));
    snmp_add_null_var(request, i2StateService, sizeof(i2StateService)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2ServiceAttributes = (i2ServiceAttributes_t *) malloc(sizeof(i2ServiceAttributes_t));
    if (! *i2ServiceAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2ServiceName)/sizeof(oid)
            && memcmp(vars->name, i2ServiceName, sizeof(i2ServiceName)) == 0) {
            memcpy((*i2ServiceAttributes)->__i2ServiceName, vars->val.string, vars->val_len);
            (*i2ServiceAttributes)->_i2ServiceNameLength = vars->val_len;
            (*i2ServiceAttributes)->i2ServiceName = (*i2ServiceAttributes)->__i2ServiceName;
        }
        if (vars->name_length > sizeof(i2StateService)/sizeof(oid)
            && memcmp(vars->name, i2StateService, sizeof(i2StateService)) == 0) {
            (*i2ServiceAttributes)->__i2StateService = *vars->val.integer;
            (*i2ServiceAttributes)->i2StateService = &((*i2ServiceAttributes)->__i2StateService);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2UserAttributes(struct snmp_session *s, i2UserAttributes_t **i2UserAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2UserPager, sizeof(i2UserPager)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2UserAttributes = (i2UserAttributes_t *) malloc(sizeof(i2UserAttributes_t));
    if (! *i2UserAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2UserPager)/sizeof(oid)
            && memcmp(vars->name, i2UserPager, sizeof(i2UserPager)) == 0) {
            memcpy((*i2UserAttributes)->__i2UserPager, vars->val.string, vars->val_len);
            (*i2UserAttributes)->_i2UserPagerLength = vars->val_len;
            (*i2UserAttributes)->i2UserPager = (*i2UserAttributes)->__i2UserPager;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2EndpointAttributes(struct snmp_session *s, i2EndpointAttributes_t **i2EndpointAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2EndpointName, sizeof(i2EndpointName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2EndpointAttributes = (i2EndpointAttributes_t *) malloc(sizeof(i2EndpointAttributes_t));
    if (! *i2EndpointAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2EndpointName)/sizeof(oid)
            && memcmp(vars->name, i2EndpointName, sizeof(i2EndpointName)) == 0) {
            memcpy((*i2EndpointAttributes)->__i2EndpointName, vars->val.string, vars->val_len);
            (*i2EndpointAttributes)->_i2EndpointNameLength = vars->val_len;
            (*i2EndpointAttributes)->i2EndpointName = (*i2EndpointAttributes)->__i2EndpointName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_i2ZoneAttributes(struct snmp_session *s, i2ZoneAttributes_t **i2ZoneAttributes)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2ZoneName, sizeof(i2ZoneName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *i2ZoneAttributes = (i2ZoneAttributes_t *) malloc(sizeof(i2ZoneAttributes_t));
    if (! *i2ZoneAttributes) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2ZoneName)/sizeof(oid)
            && memcmp(vars->name, i2ZoneName, sizeof(i2ZoneName)) == 0) {
            memcpy((*i2ZoneAttributes)->__i2ZoneName, vars->val.string, vars->val_len);
            (*i2ZoneAttributes)->_i2ZoneNameLength = vars->val_len;
            (*i2ZoneAttributes)->i2ZoneName = (*i2ZoneAttributes)->__i2ZoneName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int icinga_icinga2_mib_mgr_get_icinga2Status(struct snmp_session *s, icinga2Status_t **icinga2Status)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, i2DaemonStatus, sizeof(i2DaemonStatus)/sizeof(oid));
    snmp_add_null_var(request, i2ClusterStatus, sizeof(i2ClusterStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *icinga2Status = (icinga2Status_t *) malloc(sizeof(icinga2Status_t));
    if (! *icinga2Status) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(i2DaemonStatus)/sizeof(oid)
            && memcmp(vars->name, i2DaemonStatus, sizeof(i2DaemonStatus)) == 0) {
            (*icinga2Status)->__i2DaemonStatus = *vars->val.integer;
            (*icinga2Status)->i2DaemonStatus = &((*icinga2Status)->__i2DaemonStatus);
        }
        if (vars->name_length > sizeof(i2ClusterStatus)/sizeof(oid)
            && memcmp(vars->name, i2ClusterStatus, sizeof(i2ClusterStatus)) == 0) {
            (*icinga2Status)->__i2ClusterStatus = *vars->val.integer;
            (*icinga2Status)->i2ClusterStatus = &((*icinga2Status)->__i2ClusterStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}


